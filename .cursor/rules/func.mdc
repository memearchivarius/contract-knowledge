---
description: Instructions for creating and structuring new Func smart contract files (*.fc, *.func) for the TON blockchain using Blueprint. Includes development workflow, contract compilation, testing, and deployment guidelines.
globs: *.fc, *.func, *.functxt, *.fctxt
alwaysApply: true
---
## ✅ **Func Smart Contracts for TON Blockchain (with Blueprint)**

**Func** — a secure, low-level, blockchain-optimized programming language for writing efficient smart contracts on TON (The Open Network).

**Blueprint** — a toolkit simplifying contract compilation, testing, and deployment workflows for Func contracts.

---

## ⚡️ **Development Workflow**

- 📌 **Write contracts** inside the `contract/` directory.\
  Use allowed keywords and structures:

```plaintext
#include, #pragma, int, cell, slice, builder, cont, tuple, var, (), _,
global, const, impure, inline, inline_ref, return, if, ifnot, else,
elseif, elseifnot, repeat, while, do, until, method_id, asm, throw,
begin_cell, store_uint, store_int, end_cell, begin_parse, end_parse,
store_slice, load_uint, load_int, slice_empty?, get_data, set_data,
get_methods, load_data, save_data, recv_internal
```

- 📌 **Compile contracts**:

```bash
npx blueprint build
```

Compiled output → located in the `build/` directory.

- 📌 **Write TypeScript wrappers manually** *(contract interaction classes)*:

Wrappers → manually created in the `wrappers/` directory.

- 📌 **Testing** (logic, opcodes, exceptions):

```bash
npx blueprint test
```

- 📌 **Scripts and Deployment** (located in `scripts/` folder):

```bash
npx blueprint run
```

---

## 🚧 **Important Built-in Methods and Functions in Func**

```plaintext
get_data(), set_data(), begin_cell(), store_uint(), load_uint(), store_slice(), load_int(), throw(), recv_internal(), slice_empty?(), begin_parse(), end_parse()
```

---

## 📌 **Best Practices for Func Contracts**

- **Avoid excessive use of global state variables**\
  *(store minimal necessary data)*

- **Prefer smaller functions and clear separation of logic**\
  *(use helper functions and inline where necessary)*

- **Always audit and optimize functions involving data parsing**\
  *(consult Func documentation for opcode efficiency)*

- **Utilize ********`asm`******** for critical performance and gas optimizations**

- **Never process strings directly on-chain**\
  *(use binary data structures)*

- **Use arithmetic logic instead of conditional checks when possible**\
  *(efficient opcode usage)*, e.g.:

```func
int value = 1 + sign(msg_value);
```

- **Move pure or stateless methods outside the main contract** *(modularize into external include files)*

- \*\*Always handle errors explicitly using \*\***`throw()`**

- **Use precise cell parsing with clear ********`begin_parse()`******** / ********`end_parse()`******** structures**

- **For message sending and contract interaction**:

  - Carefully construct messages via `begin_cell()` and explicitly set fields
  - Avoid unnecessary or redundant message forwarding *(minimize gas costs)*
