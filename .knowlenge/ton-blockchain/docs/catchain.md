# Catchain Consensus: An Outline

### Nikolai Durov

### February 19, 2020

```
Abstract
The aim of this text is to provide an outline of the Catchain Consen-
sus Protocol, a Byzantine Fault Tolerant (BFT) protocol specifically
crafted for block generation and validation in the TON Blockchain [3].
This protocol can potentially be used for purposes other than block
generation in a proof-of-stake (PoS) blockchain; however, the current
implementation uses some optimizations valid only for this specific
problem.
```
## Contents

1 Overview 2

2 Catchain Protocol 5

3 Block Consensus Protocol 16


```
Chapter1. Overview
```
## 1 Overview

The Catchain Consensus protocol builds upon the overlay network construc-
tion protocol and the overlay network broadcast protocol of TON Network
([3]). The Catchain Consensus protocol itself can be decomposed into two
separate protocols, one more low-level and general-purpose (the Catchain
protocol^1 ), and the other the high-levelBlock Consensus Protocol (BCP),
which makes use of the Catchain protocol. Higher levels in the TON proto-
col stack are occupied by the block generation and validation levels; however,
all of them are executed essentially locally on one (logical) machine, with the
problem of achieving consensus on the newly-generated block delegated to
the Catchain protocol level.
Here is an approximate diagram of the protocol stack employed by TON
for block generation and distribution, showing the correct place of the Catchain
Consensus protocol (or rather its two component protocols):

- Top-level:Block generation and block validation software, logically run-
    ning on a stand-alone logical machine, with all the inputs provided and
    outputs handled by the lower-level protocols. The job of this software
    is to either generate a new valid block for a blockchain (a shardchain
    or the masterchain of the TON Blockchain; cf. [3] for a discussion of
    shardchains and the masterchain), or to check the validity of a block
    generated by somebody else.
- (TON) Block consensus protocol: Achieves (byzantine fault tolerant)
    consensus on the block to be accepted as the next one in the current
    validator group for the masterchain or a shardchain. This level makes
    use of (the abstract interface of) the block generation and validation
    software, and builds upon the lower-level Catchain protocol. This pro-
    tocol is explained in more detail in Section 3.
- Catchain protocol: Provides secure persistent broadcasts in an overlay
    network (e.g., the task group of validators for a specific shardchain or
    the masterchain dedicated to generation, validation, and propagation
    of new blocks in this shardchain or masterchain), and detects attempts

(^1) The original name of this protocol used during the initial stage of the research
and development phase wascatch-chainorcatchchain, because it essentially is a special
blockchaindedicated tocatching all events important for the consensus protocol; after
saying and writing this name a lot of times it gradually got contracted to “catchain”.


```
Chapter1. Overview
```
```
of “cheating” (protocol violation) on the part of some participants. This
protocol is explained in more detail in Section 2.
```
- (TON Network) overlay broadcast protocol: A simple best-effort broad-
    cast protocol for overlay networks in the TON Network as described in
    [3]. Simply broadcasts received broadcast messages to all neighbors in
    the same overlay network that did not receive a copy of these messages
    before, with minimal effort dedicated to keeping copies of undelivered
    broadcast messages for a short period of time.
- (TON Network) overlay protocol: Creates overlay networks (cf. [3])
    inside the ADNL protocol network, manages neighbor lists for these
    overlay networks. Each participant of an overlay network tracks sev-
    eral neighbors in the same overlay network and keeps dedicated ADNL
    connections (called“channels”) to them, so that incoming messages can
    be efficiently broadcast to all neighbors with minimal overhead.
- Abstract Datagram Network Layer (ADNL) protocol: The basic pro-
    tocol of the TON Network, that delivers packets (datagrams) between
    network nodes identified only by 256-bit abstract (ADNL) addresses,
    which effectively are cryptographic keys (or their hashes).

This text aims to describe only the second and the third protocol in this
suite, namely, the (TON) block consensus protocol and the (TON) Catchain
protocol.
We would like to point out here that the author of this text, while pro-
viding the general guidelines of how this protocol should be designed (on
the lines of “let’s create a BFT-hardened group broadcast message system,
and run a suitably adapted simple two-phase or three-phase commit proto-
col on top of this system”) and participating in several discussions during the
development and implementation of the protocol, is definitely not the only
designer of this protocol and especially of its current implementation. This
is the work of several people.
A few words on the efficiency of the combined Catchain Consensus proto-
col. Firstly, it is a true Byzantine Fault Tolerant (BFT) protocol, in the sense
that it eventually achieves consensus on a valid next block of the blockchain
even if some participants (validators) exhibit arbitrarily malicious behavior,
provided these malicious participants are less than one third of the total
number of the validators. It is well-known that achieving BFT consensus


```
Chapter1. Overview
```
is impossible if at least one third of participants are malicious (cf. [5]), so
the Catchain Consensus protocol is as good as theoretically possible in this
respect. Secondly, when the Catchain Consensus was first implemented (in
December 2018) and tested on up to 300 nodes distributed all over the world,
it achieved consensus on a new block in 6 seconds for 300 nodes and in 4–5 sec-
onds for 100 nodes (and in 3 seconds for 10 nodes), even if some of these nodes
fail to participate or exhibit incorrect behavior.^2 Since the TON Blockchain
task groups are not expected to consist of more than a hundred validators
(even if a total of a thousand or ten thousand validators are running, only
a hundred of them with the largest stakes will generate new masterchain
blocks, and the others will participate only in the creation of new shardchain
blocks, each shardchain block generated and validated by 10–30 validators;
of course, all numbers given here are configuration parameters (cf. [3] and [4])
and can be adjusted later by a consensus vote of validators if necessary), this
means that the TON Blockchain is able to generate new blocks once every
4–5 seconds, as originally planned. This promise has been further tested and
found out to be fulfilled with the launch of the Test Network of the TON
Blockchain a couple of months later (in March 2019). Therefore, we see that
the Catchain Consensus protocol is a new member of the ever-growing fam-
ily of practical BFT protocols (cf. [2]), even though it is based on slightly
different principles.

(^2) When the ratio of the malicious or non-participating or very slow validators grows up
to one third, the protocol exhibits graceful degradation, with the block consensus time
growing very slowly—say, by at most half a second—until the critical value of one third
is almost achieved.


```
Chapter2. Catchain Protocol
```
## 2 Catchain Protocol

We have already explained in the Overview (cf. 1 ) that the BFT consen-
sus protocol used by the TON Blockchain for achieving consensus on new
blockchain blocks consists of two protocols. We provide here a brief descrip-
tion of theCatchain protocol, the lower-lever of these two protocols that could
be potentially used for purposes other than BFT consensus for blocks. The
source code for the Catchcain protocol resides in subdirectorycatchainof
the source tree.

2.1. Prerequisites for running the Catchain protocol.The main pre-
requisite for running (an instance of) the Catchain protocol is the ordered
list of all nodes that are participating (or allowed to participate) in this spe-
cific instance of the protocol. This list consists of public keys and ADNL
addresses of all participating nodes. It has to be provided from the outside
when an instance of the Catchain protocol is created.

2.2. Nodes participating in the block consensus protocol. For the
specific task of creating new blocks for one of the blockchains (i.e., the mas-
terchain or one of the active shardchains) of the TON Blockchain, a special
task group consisting of several validators is created. The list of members of
this task group is used both to create a private overlay network inside ADNL
(this means that the only nodes that can join this overlay network are those
explicitly listed during its creation) and to run the corresponding instance of
the Catchain protocol.
The construction of this list of members is the responsibility of the higher
levels of the overall protocol stack (the block creation and validation software)
and therefore is not the topic of this text ([4] would be a more appropriate
reference). It is sufficient to know at this point that this list is a deterministic
function of the current (most recent) masterchain state (and especially of
the current value of the configuration parameters, such as the active list
of all validators elected for creating new blocks along with their respective
weights). Since the list is computed deterministically, all validators compute
the same lists and in particular each validator knows in which task groups
(i.e., instances of the Catchain protocol) it participates without any further
need for network communication or negotiation.^3

(^3) If some validators have an outdated masterchain state, they may fail to compute
correct task group lists and to participate in the corresponding catchains; in this respect,


```
Chapter2. Catchain Protocol
```
2.2.1. Catchains are created in advance. In fact, not only the current
values of the lists alluded to above are computed, but also their immediately
subsequent (future) values are computed as well, so that the Catchain is
usually created in advance. In this way it is already in place when the first
block has to be created by the new instance of the validator task group.

2.3. The genesis block and the identifier of a catchain. Acatchain
(i.e., an instance of the Catchain protocol) is characterized by itsgenesis block
orgenesis message. It is a simple data structure containing some magic num-
bers, the purpose of the catchain (e.g., the identifier of the shardchain, for
which the blocks will be generated, and the so-calledcatchain sequence num-
ber, also obtained from the masterchain configuration and used to distinguish
subsequent instances of the catchain generating “the same” shardchain, but
possibly with different participating validators), and, most importantly, the
list of all participating nodes (their ADNL addresses and Ed25519 public
keys as explained in2.1). The Catchain protocol itself uses only this list
and thesha256hash of the overall data structure; this hash is used as an
internal identifier of the catchain, i.e., of this specific instance of the Catchain
protocol.

2.3.1. Distribution of the genesis block. Note that the genesis block
is not distributed among the participating nodes; it is rather computed in-
dependently by each participating node as explained in2.2. Since the hash
of the genesis block is used as the catchain identifier (i.e., identifier of the
specific instance of the Catchain protocol; cf.2.3), if a node (accidentally or
intentionally) computes a different genesis block, it will be effectively locked
out from participating in the “correct” instance of the protocol.

2.3.2. List of nodes participating in a catchain.Note that the (ordered)
list of nodes participating in a catchain is fixed in the genesis block and hence
it is known to all the participants and it is unambiguously determined by the
hash of the genesis block (i.e., the catchain identifier), provided there are no
(known) collisions forsha256. Therefore, we fix the number of participating
nodesN in the discussion of one specific catchain below, and assume that
the nodes are numbered from 1 toN(their real identities may be looked up

they are treated as if they were malicious or malfunctioning and do not affect the overall
validity of the BFT protocol as long as less than one third of all validators fail in this
fashion.


```
Chapter2. Catchain Protocol
```
in the list of participants using this index in range 1 ...N). The set of all
participants will be denoted byI; we assume thatI={ 1 ...N}.

2.4. Messages in a catchain. Catchain as a process group. One
perspective is that a catchain is a(distributed) process groupconsisting ofN
known and fixed(communicating) processes(ornodesin the preceding termi-
nology), and these processes generatebroadcast messages, that are eventually
broadcast to all members of the process group. The set of all processes is de-
noted byI; we usually assume thatI={ 1 ...N}. The broadcasts generated
by each process are numbered starting from one, so then-th broadcast of
processiwill receivesequence numberorheightn; each broadcast should be
uniquely determined by the identity or the indexiof the originating process
and its heightn, so we can think of the pair(i,n)as the natural identifier
of a broadcast message inside a process group.^4 The broadcasts generated
by the same processiare expected to be delivered to every other process in
exactly the same order they have been created, i.e., in increasing order of
their height. In this respect a catchain is very similar to a process group in
the sense of [1] or [7]. The principal difference is that a catchain is a “hard-
ened” version of a process group tolerant to possible Byzantine (arbitrarily
malicious) behavior of some participants.

2.4.1. Dependence relation on messages. One can introduce adepen-
dence relationon all messages broadcast in a process group. This relation
must be a strict partial order ≺, with the property that mi,k ≺ mi,k+1,
wheremi,k denotes thek-th message broadcast by group member process
with indexi. The meaning ofm ≺m′ is that m′ depends on m, so that
the (broadcast) messagem′can be processed (by a member of the process
group) only ifmhas been processed before. For instance, if the messagem′
represents the reaction of a group member to another messagem, then it is
natural to setm≺m′. If a member of the process group receives a message
m′before all its dependencies, i.e., messagesm≺m′, have been processed
(ordeliveredto the higher-level protocol), then its processing (ordelivery) is
delayed until all its dependencies are delivered.
We have defined the dependence relation to be a strict partial order, so
it must be transitive (m′′≺m′andm′≺mimplym′′≺m), antisymmetric
(at most one ofm′ ≺ mandm ≺ m′ can hold for any two messagesm
andm′) and anti-reflexive (m≺mnever holds). If we have a smaller set

(^4) In the Byzantine environment of a catchain this is not necessarily true in all situations.


```
Chapter2. Catchain Protocol
```
of “basic dependencies”m′→m, we can construct its transitive closure→+
and put≺:=→+. The only other requirement is that every broadcast of
a sender depends on all previous broadcasts of the same sender. It is not
strictly necessary to assume this; however, this assumption is quite natural
and considerably simplifies the design of a messaging system inside a process
group, so the Catchain protocol makes this assumption.

2.4.2. Dependence set or cone of a message. Letmbe a (broadcast)
message inside a process group as above. We say that the setDm:={m′ :
m′≺m}is thedependence set ordependence coneof messagem. In other
words, Dm is theprincipal ideal generated by m in the partially ordered
finite set of all messages. It is precisely the set of all messages that must be
delivered beforemis delivered.

2.4.3. Extended dependence cone of a message. We also defineD+m,
theextended dependence cone ofm,byD+m:=Dm∪{m}.

2.4.4. Cones, or ideals with respect to ≺. More generally, we say
that a subsetDof messages is aconeif it is an ideal with respect to the
dependence relation ≺, i.e., if m ∈ D andm′ ≺ m implym′ ∈ D. Of
course, the dependence coneDm and the extended dependence coneD+mof
any messagemare cones (because any principal ideal in a partially ordered
set is an ideal).

2.4.5. Identification of cones with the aid of vector time.Recall that
we have assumed that any message depends on all preceding messages of the
same sender, i.e.mi,s≺mi,s+1for anyi∈Iand anys > 0 , such thatmi,s+
exists. This implies that any coneDis completely characterized byNvalues
Vt(D)iindexed byi∈I:

```
Vt(D)i:= sup{s∈N: mi,s∈D}= inf{s∈N 0 : mi,s+16∈D} (1)
```
(if no messagemi,sis inD, we setVt(D)i:= 0). Indeed, it is clear that

```
mi,s∈D⇔s≤Vt(D)i (2)
```
We say that the vectorVt(D) = (Vt(D)i)i∈I∈NI 0 with non-negative com-
ponentsVt(D)i is thevector time or vector timestamp corresponding to
coneD(cf. [1] or [7] for a more detailed discussion of vector time).


```
Chapter2. Catchain Protocol
```
2.4.6. Partial order on vector timestamps.We introduce a partial order
≤on the set of all possible vector timesNI 0 , which is the product of the usual
orders onN 0 :

```
x= (xi)i∈I≤y= (yi)i∈I iff xi≤yi for alli∈I (3)
```
It is immediate thatD⊂D′ iffVt(D)≤Vt(D′); therefore,Vtis a strict
order-preserving embedding of the set of all cones contained in the set of all
messages intoNI 0.

2.4.7. Vector timestampVt(m)of a messagem.Given any messagem,
we define itsvector timestampVt(m)asVt(Dm). In other words, message
mcan be delivered only after the firstVt(m)jmessages generated by process
jare delivered, and this is true for allj∈I.
Ifi is the sender of messagem, andsis the height of messagem, so
thatm =mi,s, then Vt(m)i= s− 1. We can define the adjusted vector
timestampVt+(m)of messagemby settingV T+(m)j=V T(m)j forj 6 =i,
V T+(m)i = Vt(m)i+ 1 = s. Alternatively, Vt+(m) = Vt(D+m), where
D+m:=Dm∪{m}is theextended dependence cone ofm(cf.2.4.3).
Note thatm′miffD+m′ ⊂D+m iffVt+(m′)≤Vt+(m)inNI 0 , where
m′mmeans “m′≺morm′=m”. Similarly,m′≺miffD+m′⊂Dmiff
Vt+(m′)≤Vt(m). In other words,the dependence relation≺on (some or
all) messages is completely determined by the adjusted vector timestamps of
these messages.

2.4.8. Using vector timestamps to correctly deliver broadcast mes-
sages. Vector timestamps can be used (in non-byzantine settings) to cor-
rectly deliver messages broadcast in a process group.^5 Namely, suppose
that every broadcast messagem =mi,s contains the index of its senderi
and the vector timestamp of this message Vt(m). Then each receiverj
knows whether the message can be delivered or not. For this,jkeeps track
of the coneCj of all messages delivered so far, for example by maintain-
ing acurrent timestampVt(j)equal toVt(Cj). In other words,Vt(j)k
is the count of messages of senderk processed by jso far. If Vt(m)≤
Vt(j), then the messagemis delivered immediately andVt(j)is updated
tosup(Vt(j),Vt+(m))afterwards; this is equivalent to increasingVt(j)iby

(^5) We assume that all broadcast messages in the process group are “causal broadcasts”
or “cbcast” in the terminology of [1], because we only need cbcasts for the implementation
of Catchain protocol and Catchain consensus.


```
Chapter2. Catchain Protocol
```
one, whereiis the original sender of messagem. If this condition is not met,
thenmmay be put into a waiting queue untilVt(j)becomes large enough.
Instead of passively waiting for the required broadcasts, j can construct
the list of message indices(i′,s′)that are implicitly mentioned inVt(m)of
some received but not delivered messagem, and request messages with these
indices from the neighbors from whichjlearned aboutmandVt(m); an al-
ternative strategy (actually employed by the current implementation of the
Catchain protocol) is to request these messages from randomly chosen neigh-
bors from time to time. The latter strategy is simpler because it does not
require remembering the immediate sources of all received messages (which
may become unavailable anyway).

2.5. Message structure in a catchain. Catchain as a multi-blockchain.
The message structure in a catchain is a bit more complicated than described
above because of the necessity to support a BFT protocol. In particular,
vector timestamps are not sufficient in a Byzantine setting. They have to
be complemented by descriptions based on maximal elements of a depen-
dence cone (such descriptions are typically used in non-byzantine settings
only when the process group is very large, so that vector timestamp sizes
become prohibitive).

2.5.1. Describing cones by means of their maximal elements. An
alternative way (to using a vector timestamp) of describing a message cone
Dis by listing all itsmaximal elementsMax(D), i.e. elementsm∈D, such
thatm≺m′does not hold for anym′∈D. Of course, one needs a suitable
way of referring to messages without including them completely in order for
this representation to be practical.

2.5.2. Message identifiers inside a catchain. Catchain protocol uses
sha256hashes of (suitably serialized) messages as their unique identifiers. If
we assume that there are no collisions forsha256(computable in reasonable,
e.g., polynomial time), then a messagemis completely identified within the
process group by its hashsha256(m).

2.5.3. Message headers. The header of a messagem = mi,s inside a
catchain (i.e., an instance of the Catchain protocol) always contains the index
iof its sender, the heights, the catchain identifier (i.e., the hash of the genesis
message, cf.2.3) and the set of hashes of maximal elements of the dependence
cone ofm, i.e., the set{sha256(m′) : m′∈Max(Dm)}. In particular, the


```
Chapter2. Catchain Protocol
```
hashsha256(mi,s− 1 )of the previous message of the same sender is always
included sincemi,s− 1 ∈Max(Dm)ifs > 1 ; for performance reasons, there is
a separate field in the message header containingsha256(mi,s− 1 ). Ifs= 1,
then there is no previous message, so the hash of the genesis message (i.e.,
the catchain identifier, cf.2.3) is used instead.
The vector timestamp Vt(m)is not included in the message header;
however, the header implicitly determinesVt(m)since

```
Vt(m) = sup
m′∈Dm
```
```
Vt+(m′) = sup
m′∈Max(Dm)
```
```
Vt+(m′) (4)
```
Note that the message header is a part of the message, and in particular
the hash of a message (i.e., the message identifier) depends on all data listed
in the header. Therefore, we assume that the message identifier implicitly
determines all the dependencies of the corresponding message (if there are
no known collisions forsha256).

2.5.4. Message signatures.Apart from that, every message in a catchain
is signed by its creator. Since the list of participating nodes (processes) in
a catchain is known in advance, and this list includes the public keys of all
processes, these message signatures can be checked by a receiving process im-
mediately after a message is received. If the signature is invalid, the message
is discarded without any further processing.

2.5.5. Message encryption.All messages in a catchain are also encrypted
before being transferred from a node to its neighbor in the private overlay
network underlying the catchain. However, this encryption is performed by
lower-level network protocols (such as ADNL) and is not relevant to the
discussion here. We would like to mention that correct encryption is possible
here only because the list of participating processes includes not only the
public keys of all processes, but also their ADNL addresses (which effectively
are public encryption keys for network transmission).
Notice that even if the encryption had been absent, this would not violate
the BFT properties of the protocol, because faking a message from another
sender would not be possible because of the signatures. However, this might
lead to a leak of information to outside observers, which is often undesirable.

2.5.6. Alternative perspective: a catchain as a multi-blockchain.
Note that all messages created by the same senderiin a catchain turn out to
have a simple “blockchain structure”, because the header ofmi,s+1contains


```
Chapter2. Catchain Protocol
```
the hashsha256(mi,s)(among other hashes of messages fromMax(Dmi,s+1))
of the previous message of senderi. In this way each processigenerates a sim-
ple blockchain consisting of its messages, with each “block” of this blockchain
corresponding to one message and referring to the previous block by its hash,
and sometimes includes references to blocks (i.e., messages) of other processes
by mentioning the hashes of these blocks in its blocks. Each block is signed
by its creator. The resulting structure is very similar to that of an “asyn-
chronous payment channel” considered in [3, 5], but withN participants
instead of 2.

2.6. Message propagation in a catchain.Now we are ready to describe
message propagation in a catchain. Namely:

- The (lower-level) overlay network protocol maintains a list of neighbors
    in the private overlay network underlying the catchain and provides
    ADNL channels to each of these neighbors. This private overlay net-
    work has the same list of members (processes, nodes) as the catchain,
    and the neighbors of each node form an (oriented) subgraph on the
    set of all participating nodes. This (essentially random) subgraph is
    strongly connected with probability very close to one.
- Each process generates some new messages from time to time (as needed
    by the higher-level protocol). These messages are augmented by catchain
    message headers as outlined in 2.5.3, signed, and propagated to all
    known neighbors using the ADNL channels established by the overlay
    protocol.
- In contrast with the usual simple overlay broadcast protocol, the mes-
    sages received from neighbors are not immediately rebroadcast to all
    other neighbors that are not known yet to have a copy of them. Instead,
    the signature is checked first, and invalid messages are discarded. Then
    the message is either delivered (if all its dependent messages have al-
    ready been delivered), or put into a waiting queue. In the latter case, all
    the required messages mentioned in its header (i.e., the setMax(Dm))
    are pulled from the neighbor that sent this message (apart from that,
    attempts to download these missing messages from random neighbors
    are performed from time to time). If necessary, this process is repeated
    recursively until some messages can be delivered. Once a message is
    ready for local delivery (i.e., all its dependencies are already present),
    it is also rebroadcast to all neighbors in the overlay network.


```
Chapter2. Catchain Protocol
```
- Apart from the recursive “pull” mechanism described above, a faster
    vector timestamp-based mechanism is also used, so that messages can
    be queried from neighbors by their senders and heights (learned from
    the vector timestamps of received messages). Namely, each process
    sends a special query containing the current vector timestamp to a
    randomly chosen neighbor from time to time. This peer-to-peer query
    leads to its receiver sending back all or some messages unknown to the
    sender (judging by their vector timestamps).
- This faster vector timestamp-based mechanism can be disabled for mes-
    sages originating from certain senders as soon as a “fork” is detected,
    i.e., a second message with the same senderiand heights, but with
    a different hash, is learned from a neighbor, for example, during the
    fast or slow “pull” process. Once a fork created byiis detected, the
    corresponding componentVtiof all subsequent vector timestamps is
    set to a special value∞to indicate that comparing the values of these
    components does not make sense anymore.
- When a message is delivered (to the higher-level protocol), this message
    is added into the coneC of processed messages of the current process
    (and the current vector timestamp is updated accordingly), and all sub-
    sequent messages generated by the current process will be assumed to
    depend on all the messages delivered so far (even if this is not logically
    necessary from the perspective of the higher-level protocol).
- If the setMax(C)of the maximal elements of the cone of processed
    messages becomes too large (contains more elements than a certain
    amount fixed in advance by the genesis message of the catchain), then
    the Catchain protocol asks the higher-level protocol to generate a new
    message (empty if no useful payload is available). After this new mes-
    sage is generated (and immediately delivered to the current process),C
    is updated andMax(C)consists of only one element (the new message).
    In this way the size ofMax(C)and therefore the size of the message
    header always remain bounded.
- Once a messagemis delivered and the setC is modified to include
    this message, a timer is set, and after some small delay the higher-
    level protocol is asked to create a new message (empty if necessary),
    so that this new messagem∗ would refer to the newC, similarly to


```
Chapter2. Catchain Protocol
```
```
the procedure described in the previous item. This new messagem∗
is pushed to all neighbors; since its header containsMax(C)for the
newC, andm ∈ C, the neighbors learn not only about the newly-
generated messagem∗, but also about the original received messagem.
If some neighbors do not have a copy ofmyet, they would require one
(from the current process or not).
```
- All (broadcast) messages received and created in a catchain are stored
    into a special local database. This is especially important for newly-
    created messages (cf.3.3.2): if a message is created and sent to neigh-
    bors, but not saved into the database (and flushed to disk) before the
    creating process crashes and is restarted, then another message with
    the same sender and height can be created after restart, thus effectively
    leading to an involuntary “fork”.

2.7. Forks and their prevention. One can see that the multi-blockchain
structure of a catchain outlined above (with references to other blocks by
their hashes and with signatures) leaves very little possibility for “cheating”
in a consensus protocol built upon a catchain (i.e., using the catchain as a
means for broadcasting messages inside a process group). The only possibility
that is not detected immediately consists of creating two (or more) different
versions of the same messagemi,s(say,m′i,sandm′′i,s), and sending one version
of this messagem′i,sto some peers and a different versionm′′i,sto others. If
sis minimal (for a fixed i), then this corresponds to afork in blockchain
terminology: two different next blocksm′i,sandm′′i,sfor the same previous
blockmi,s− 1.
Therefore, the Catchain protocol takes care to detect forks as soon as
possible and prevent their propagation.

2.7.1. Detection of forks. The detection of forks is simple: if there are
two different blocksm′i,sandm′′i,swith the same creatori∈Iand the same
heights≥ 1 , and with valid signatures ofi, then this is a fork.

2.7.2. Fork proofs. Block signatures in the Catchain protocol are created
in such a way that creatingfork proofs(i.e., the proof that a processihas
intentionally created a fork) is especially simple since it is the hash of a very
small structure (containing a magic number, the values ofiands, and the
hash of the remainder of the message) that is actually signed. Therefore, only
two such small structures and two signatures are required in a fork proof.


```
Chapter2. Catchain Protocol
```
2.7.3. External punishment for creating forks.Notice that an external
punishment for creating catchain forks may be used in the proof-of-stake
blockchain generation context. Namely, the fork proofs may be submitted
to a special smart contract (such as the elector smart contract of the TON
Blockchain), checked automatically, and some part or all of the stake of the
offending party may be confiscated.

2.7.4. Internal processing of forks.Once a fork (created byi) is detected
(by another processj), i.e.jlearns about two different messagesmi,sandm′i,s
created byiand having same heights(usually this happens while recursively
downloading dependencies of some other messages),jstarts ignoringiand
all of its subsequent messages. They are not accepted and not broadcast
further. However, messages created byiprior to the fork detection may
be still downloaded if they are referred to in messages (blocks) created by
processes that did not see this fork before referring to such messages created
byi.

2.7.5. Accepting messages from a “bad” process is bad.Furthermore,
if processilearns about a fork created by processj, then ishows this to
its neighbors by creating a new service broadcast message that contains the
corresponding fork proof (cf.2.7.2). Afterwards, this and all subsequent
messages ofjcannot directly depend on any messages by the known “bad”
produceri(but they still can refer to messages from another partykthat
directly or indirectly refer to messages of iif no fork byiwas known to
k at the time when the referring message was created). Ifj violates this
restriction and creates messages with such invalid references, these messages
will be discarded by all honest processes in the group.

2.7.6. The set of “bad” group members is a part of the intrinsic
state.Each processikeeps its own copy of the set of known “bad” processes
in the group, i.e., those processes that have created at least one fork or have
violated2.7.5. This set is updated by addingjinto it as soon asilearns
about a fork created byj (or about a violation of2.7.5byj); after that,
a callback provided by the higher-level protocol is invoked. This set is used
when a new broadcast message arrives: if the sender is bad, then the message
is ignored and discarded.


```
Chapter3. Block Consensus Protocol
```
## 3 Block Consensus Protocol

We explain in this section the basic workings of the TON Block Consensus
Protocol (cf. 1 ), which builds upon the generic Catchain protocol (cf. 2 ) to
provide the BFT protocol employed for generating and validating new blocks
of the TON Blockchain. The source code for the TON Block Consensus
protocol resides in subdirectoryvalidator-sessionof the source tree.

3.1. Internal state of the Block Consensus Protocol.The higher-level
Block Consensus Protocol introduces a new notion to the catchain: that of
aninternal state of the Block Consensus Protocol (BCP), sometimes also
(not quite correctly) called “the internal state of the catchain” or simply
catchain state. Namely, each processi∈I has a well-determined internal
stateσCiafter a subset of messages (actually always a dependence cone)Ci
is delivered by the Catchain protocol to the higher-level protocol (i.e., to the
Block Consensus Protocol in this case). Furthermore, this stateσCi=σ(Ci)
depends only on coneCi, but not on the identity of the processi∈I, and can
be defined for any dependence coneS(not necessarily a coneCiof delivered
messages for some processiat some point).

3.1.1. Abstract structure of the internal state. We start with an ab-
stract structure of the internal state employed by BCP; more specific details
will be provided later.

3.1.2. Updating the internal state.The Catchain protocol knows nothing
about the internal state; it simply invokes appropriate callbacks supplied by
the higher-level protocol (i.e., the BCP) whenever a messagemis delivered.
It is the job of the higher-level protocol to compute the new stateσS′starting
from the previously computed stateσS and the messagem, where S′ =
S∪{m}(and necessarilyS⊃Dm, otherwisemcould not have been delivered
at this point).

3.1.3. Recursive formula for updating the internal state. The ab-
stract setup for computingσSfor all conesSconsists of three components:

- A valueσ∅ for the initial state (this value actually depends on the
    genesis block of the catchain; we ignore this dependence here because
    we consider only one catchain at this point).


```
Chapter3. Block Consensus Protocol
```
- A functionfthat computes the stateσD+mfrom the previous stateσDm
    and the newly-delivered messagem:

```
σD+m=f(σDm,m) (5)
```
```
whereDmis the dependence cone of messagemandDm+=Dm∪{m}
its extended dependence cone (cf.2.4.3). In most cases,fwill actually
satisfy the stronger condition
```
```
σS∪{m}=f(σS,m) ifSandS∪{m}are cones andm6∈S (6)
```
```
However, this stronger condition is not required by the update algo-
rithm.
```
- A “merge function”gthat computesσS∪T fromσSandσT:

```
σS∪T=g(σS,σT) for any conesSandT (7)
```
```
(the union of two cones always is a cone). This functionσis applied
by the update algorithm only in the specific caseT=D+mandm6∈S.
```
3.1.4. Commutativity and associativity of g. Note that (7) (for ar-
bitrary conesS and T) implies associativity and commutativity ofg, at
least whengis applied to possible states (values of formσS for some cone
S). In this respectgdefines a commutative monoid structure on the set
Σ ={σS : Sis a cone}. Usuallygis defined or partially defined on a larger
setΣ ̃of state-like values, and it may be commutative and associative on this
larger setΣ ̃, i.e.,g(x,y) =g(y,x)andg(x,g(y,z)) =g(g(x,y),z)forx,y,
z∈Σ ̃(whenever both sides of the equality are defined), withσ∅as an unit,
i.e.,g(x,σ∅) =x=g(σ∅,x)forx∈S ̃(under the same condition). However,
this property, useful for the formal analysis of the consensus algorithm, is
not strictly required by the state update algorithm, because this algorithm
usesgin a deterministic fashion to computeσS.

3.1.5. Commutativity off.Note thatf, if it satisfies the stronger condi-
tion (6), must also exhibit a commutativity property

```
f
```
#### (

```
f(σS,m),m′
```
#### )

```
=f
```
#### (

```
f(σS,m′),m
```
#### )

#### (8)

wheneverSis a cone andmandm′are two messages withDm⊂S,Dm′⊂S,
m6∈Sandm′6∈S, because in this caseS∪{m},S∪{m′}andS∪{m,m′}


```
Chapter3. Block Consensus Protocol
```
are also cones, and (6) implies that both sides of (8) are equal toσS∪{m,m′}.
Similarly to3.1.4,fis usually defined or partially defined on the product of
a larger setΣ ̃of state-like values and of a set of message-like values; it may
exhibit the “commutativity” property (8) or not on this larger set. If it does,
this might be useful for formal analysis of the algorithms relying onσS, but
this property is not strictly necessary.

3.1.6. The state update algorithm. The state update algorithm (inde-
pendently executed by each processi) employed by the catchain (actually by
the higher-level BCP) usesσ∅,fandgas follows:

- The algorithm keeps track of allσD+mfor all messagesmdelivered so
    far.
- The algorithm keeps track ofσCi, whereCiis the current dependence
    cone, i.e., the set of all messagesmdelivered (to the current processi).
    The initial value ofσCiisσ∅.
- When a new messagemis delivered, the value ofσDmis computed by a
    repeated application ofgsinceDm=

#### ⋃

```
m′∈DmD
```
```
+
m′=
```
#### ⋃

```
m′∈Max(Dm)D
```
```
+
m′;
therefore, ifMax(Dm) ={m′ 1 ,...,m′k}, then
```
```
σDm=g
```
#### (

```
...g
```
#### (

```
g(σD+
m′ 1
,σD+
m′ 2
),σD+
m′ 3
```
#### )

```
,...σD+
m′k
```
#### )

#### . (9)

```
The setMax(Dm)is explicitly listed in the header of messagemin some
fixed orderm′ 1 ,... ,m′k; the above formula is applied with respect to this
order (so the computation ofDm is deterministic). The first element
in this list always is the previous message of the sender ofm, i.e., if
m=mi,s+1, thenm′ 1 =mi,s.
```
- After that, the value ofσD+mis computed by an application off:σDm+=
    f(σDm,m). This value is memorized for future use.
- Finally, when a new messagemis delivered to the current processi,
    thus updatingCitoCi′:=Ci∪{m}, the algorithm uses the computed
    valueσD+mto update the current state

```
σCi′=g(σCi,σD+m) (10)
```
```
This state, however, is “virtual” in the sense that it can be slightly
changed later (especially ifgis not commutative). Nevertheless, it is
```

```
Chapter3. Block Consensus Protocol
```
```
used to make some important decisions by the higher-level algorithm
(BCP).
```
- Once a new messagemis generated and locally delivered, so thatCi
    becomes equal toDm+, the previously computed value ofσCiis discarded
    and replaced withσD+mcomputed according to the general algorithm
    described above. Ifgis not commutative or not associative (for exam-
    ple, it may happen thatg(x,y)andg(y,x)are different but equivalent
    representations of the same state), then this might lead to a slight
    change of the current “virtual” state of processi.
- If the lower-level (catchain) protocol reports to the higher-level protocol
    that a certain processj6∈iis “bad” (i.e.,jis found out to have created
    a fork, cf.2.7.6, or to have knowingly endorsed a fork by another pro-
    cess, cf.2.7.5), then the current (virtual) stateσCiis recomputed from
    scratch using the new setCi′=

#### ⋃

```
m∈Ci,mwas created by “good” processkD
```
```
+
m
and the “merge” functiongapplied to the set ofσDm+ wheremruns
through the set of last messages of the processes known to be good (or
through the set of maximal elements of this set). The next created
outbound message will depend only on the messages fromC′i.
```
3.1.7. Necessity to know the internal state of the other processes.
Formula (9) implies that processimust also keep track ofσD+mfor all messages
m, created by this process or not. However, this is possible since these
internal states are also computed by appropriate applications of the update
algorithm. Therefore, BCP computes and remembers allσDm+as well.

3.1.8. Functionfwould suffice.Notice that the update algorithm applies
gonly to computeσS∪Dm+=g(σS,σD+m)whenSis a cone containingDm, but
not containingm. Therefore, every actual application ofgcould have been
replaced by an application offsatisfying the extended property (6):

```
σS∪D+m=g(σS,σD+m) =f(σS,m) (11)
```
However, the update algorithm does not use this “optimization”, because it
would disable the more important optimizations described below in3.2.
and3.2.5.

3.2. The structure of the internal state. The structure of the internal
state is optimized to make thetransition function f of (5) and themerge


```
Chapter3. Block Consensus Protocol
```
functiongof (7) as efficiently computable as possible, preferably without the
need of potentially unbounded recursion (just some loops). This motivates
the inclusion of additional components into the internal state (even if these
components are computable from the remainder of the internal state), which
have to be stored and updated as well. This process of including additional
components is similar to that employed while solving problems using dynamic
programming, or to that used while proving statements by mathematical (or
structural) induction.

3.2.1. The internal state is a representation of a value of an abstract
algebraic data type. The internal representation of the internal state is
essentially a (directed) tree (or rather a directed acyclic graph) or a collection
of nodes; each node contains some immediate (usually integer) values and
several pointers to other (previously constructed) nodes. If necessary, an
extraconstructor tag(a small integer) is added at the beginning of a node
to distinguish between several possibilities. This structure is very similar to
that used to represent values of abstract algebraic data types in functional
programming languages such as Haskell.

3.2.2. The internal state is persistent. The internal state ispersistent,
in the sense that the memory used to allocate the nodes which are part of
the internal state is never freed up while the catchain is active. Furthermore,
the internal state of a catchain is actually allocated inside a huge contiguous
memory buffer, and new nodes are always allocated at the end of the used
portion of this buffer by advancing a pointer. In this way the references to
other nodes from a node inside this buffer may be represented by an integer
offset from the start of the buffer. Every internal state is represented by a
pointer to its root node inside this buffer; this pointer can be also represented
by an integer offset from the start of the buffer.

3.2.3. The internal state of a catchain is flushed to an append-only
file.The consequence of the structure of the buffer used to store the internal
states of a catchain explained above is that it is updated only by appending
some new data at its end. This means that the internal state (or rather the
buffer containing all the required internal states) of a catchain can be flushed
to an append-only file, and easily recovered after a restart. The only other
data that needs to be stored before restarts is the offset (from the start of
the buffer, i.e., of this file) of the current state of the catchain. A simple
key-value database can be used for this purpose.


```
Chapter3. Block Consensus Protocol
```
3.2.4. Sharing data between different states.It turns out that the tree
(or rather the dag) representing the new stateσS∪{m}=f(σS,m)shares large
subtrees with the previous stateσS, and, similarly,σS∪T =g(σS,σT)shares
large subtrees withσSandσT. The persistent structure used for representing
the states in BCP makes it possible to reuse the same pointers inside the
buffer for representing such shared data structures instead of duplicating
them.

3.2.5. Memoizing nodes. Another technique employed while computing
new states (i.e., the values of functionf) is that ofmemoizing new nodes, also
borrowed from functional programming languages. Namely, whenever a new
node is constructed (inside the huge buffer containing all states for a specific
catchain), its hash is computed, and a simple hash table is used to look up
the latest node with the same hash. If a node with this hash is found, and
it has the same contents, then the newly-constructed node is discarded and
a reference to the old node with the same contents is returned instead. On
the other hand, if no copy of the new node is found, then the hash table is
updated, the end-of-buffer (allocation) pointer is advanced, and the pointer
to the new node is returned to the caller.
In this way if different processes end up making similar computations and
having similar states, large portions of these states will be shared even if they
are not directly related by application of functionfas explained in3.2.4.

3.2.6. Importance of optimization techniques.The optimization tech-
niques3.2.4and3.2.5used for sharing parts of different internal states inside
the same catchain are drastically important for improving the memory profile
and the performance of BCM in a large process group. The improvement is
several orders of magnitude in groups ofN≈ 100 processes. Without these
optimizations BCM would not be fit for its intended purpose (BFT consensus
on new blocks generated by validators in the TON Blockchain).

3.2.7. Message m contains a hash of state σD+m. Every message m
contains a (Merkle) hash of (the abstract representation of) the corresponding
stateσD+m. Very roughly, this hash is computed recursively using the tree of
nodes representation of3.2.1: all node references inside a node are replaced
with (recursively computed) hashes of the referred nodes, and a simple 64-bit
hash of the resulting byte sequence is computed. This hash is also used for
memoization as described in3.2.5.
The purpose of this field in messages is to provide a sanity check for the


```
Chapter3. Block Consensus Protocol
```
computations ofσD+mperformed by different processes (and possibly by differ-
ent implementations of the state update algorithm): onceσD+mis computed
for a newly-delivered messagem, the hash of computedσDm+is compared to
the value stored in the header ofm. If these values are not equal, an error
message is output into an error log (and no further actions are taken by the
software). These error logs can be examined to detect bugs or incompatibil-
ities between different versions of BCP.

3.3. State recovery after restart or crashes. A catchain is typically
used by the BCP for several minutes; during this period, the program (the
validator software) running the Catchain protocol may be terminated and
restarted, either deliberately (e.g., because of a scheduled software update)
or unintentionally (the program might crash because of a bug in this or some
other subsystem, and be restarted afterwards). One way of dealing with this
situation would be to ignore all catchains not created after the last restart.
However, this would lead to some validators not participating in creating any
blocks for several minutes (until the next catchain instances are created),
which is undesirable. Therefore, a catchain state recovery protocol is run
instead after every restart, so that the validator can continue participating
in the same catchain.

3.3.1. Database of all delivered messages. To this end, a special
database is created for each active catchain. This database contains all
known and delivered messages, indexed by their identifiers (hashes). A sim-
ple key-value database suffices for this purpose. The hash of the most recent
outbound messagem=mi,sgenerated by the current processiis also stored
in this database. After restart, all messages up tom are recursively de-
livered in proper order (in the same way as if all these messages had been
just received from the network in an arbitrary order) and processed by the
higher-level protocol, untilmfinally is delivered, thus recovering the current
state.

3.3.2. Flushing new messages to disk.We have already explained in2.6
that newly-created messages are stored in the database of all delivered mes-
sages (cf.3.3.1) and the database is flushed to disk before the new message
is sent to all network neighbors. In this way we can be sure that the mes-
sage cannot be lost if the system crashes and is restarted, thus avoiding the
creation of involuntary forks.


```
Chapter3. Block Consensus Protocol
```
3.3.3. Avoiding the recomputation of statesσD+m.An implementation
might use an append-only file containing all previously computed states as
described in3.2.3to avoid recomputing all states after restart, trading off
disk space for computational power. However, the current implementation
does not use this optimization.

3.4. High-level description of Block Consensus Protocol. Now we
are ready to present a high-level description of the Block Consensus Protocol
employed by TON Blockchain validators to generate and achieve consensus
on new blockchain blocks. Essentially, it is a three-phase commit protocol
that runs over a catchain (an instance of the Catchain protocol), which is
used as a “hardened” message broadcast system in a process group.

3.4.1. Creation of new catchain messages. Recall that the lower-level
Catchain protocol does not create broadcast messages on its own (with the
only exception being service broadcasts with fork proofs, cf.2.7.5). Instead,
when a new message needs to be created, the higher-level protocol (BCP)
is asked to do this by invoking a callback. Apart from that, the creation of
new messages may be triggered by changes in the current virtual state and
by timer alarms.

3.4.2. Payload of catchain messages.In this way the payload of catchain
messages is always determined by the higher level protocol, such as BCP. For
BCP, this payload consists of

- Current Unix time. It must be non-decreasing on subsequent messages
    of the same process. (If this restriction is violated, all processes pro-
    cessing this message will tacitly replace this Unix time by the maximum
    Unix time seen in previous messages of the same sender.)
- Several (zero or more)BCP eventsof one of the admissible types listed
    below.

3.4.3. BCP events.We have just explained that the payload of a catchain
message contains several (possibly zero) BCP events. Now we list all admis-
sible BCP event types.

- Submit(round,candidate)— suggest a new block candidate
- Approve(round,candidate,signature)— a block candidate has passed
    local validation


```
Chapter3. Block Consensus Protocol
```
- Reject(round,candidate)— a block candidate has failed local valida-
    tion
- CommitSign(round,candidate,signature)— a block candidate has been
    accepted and signed
- Vote(round,candidate)— a vote for a block candidate
- VoteFor(round,candidate)— this block candidate must be voted for
    in this round (even if the current process has another opinion)
- PreCommit(round,candidate)— a preliminary commitment to a block
    candidate (used in three-phase commit scheme)

3.4.4. Protocol parameters.Several parameters of BCP must be fixed in
advance (in the genesis message of the catchain, where they are initialized
from the values of the configuration parameters extracted from the current
masterchain state):

- K— duration of one attempt (in seconds). It is an integer amount of
    seconds in the current implementation; however, this is an implemen-
    tation detail, not a restriction of the protocol
- Y — number offastattempts to accept a candidate
- C— block candidates suggested during one round
- ∆ifor 1 ≤i≤C— delay before suggesting the block candidate with
    priorityi
- ∆∞— delay before approving the null candidate

Possible values for these parameters areK= 8,Y= 3,C= 2,∆i= 2(i−1),
∆∞= 2C.

3.4.5. Protocol overview. The BCP consists of severalrounds that are
executed inside the same catchain. More than one round may be active at
one point of time, because some phases of a round may overlap with other
phases of other rounds. Therefore, all BCP events contain an explicit round
identifierround(a small integer starting from zero). Every round is termi-
nated either by (collectively) accepting ablock candidate suggested by one
of the participating processes, or by accepting a specialnull candidate—a


```
Chapter3. Block Consensus Protocol
```
dummy value indicating that no real block candidate was accepted, for ex-
ample because no block candidates were suggested at all. After a round
is terminated (from the perspective of a participating process), i.e., once a
block candidate collectsCommitSignsignatures of more than 2 / 3 of all val-
idators, onlyCommitSignevents may be added to that round; the process
automatically starts participating in the next round (with the next identifier)
and ignores all BCP events with different values ofround.^6
Each round is subdivided into several attempts. Each attempt lasts a
predetermined time period ofKseconds (BCP uses clocks to measure time
and time intervals and assumes that clocks of “good” processes are more or
less in agreement with each other; therefore, BCP is not an asynchronous
BFT protocol). Each attempt starts at Unixtime exactly divisible by K
and lasts forKseconds. The attempt identifierattemptis the Unixtime of
its start divided byK. Therefore, the attempts are numbered more or less
consecutively by 32-bit integers, but not starting from zero. The firstY
attempts of a round arefast; the remaining attempts areslow.

3.4.6. Attempt identification. Fast and slow attempts. In contrast
with rounds, BCP events do not have a parameter to indicate the attempt
they belong to. Instead, this attempt is implicitly determined by the Unix
time indicated in the payload of the catchain message containing the BCP
event (cf.3.4.2). Furthermore, the attempts are subdivided intofast (the
firstY attempts of a round in which a process takes part) andslow (the
subsequent attempts of the same round). This subdivision is also implicit:
the first BCP event sent by a process in a round belongs to a certain attempt,
andY attempts starting from this one are considered fast by this process.

3.4.7. Block producers and block candidates.There areCdesignated
block producers (member processes) in each round. The (ordered) list of these
block producers is computed by a deterministic algorithm (in the simplest
case, processesi,i+1,... ,i+C− 1 are used in thei-th round, with the indices
taken moduloN, the total number of processes in the catchain) and is known
to all participants without any extra communication or negotiation. The
processes are ordered in this list by decreasing priority, so the first member
of the list has the highest priority (i.e., if it suggests a block candidate in

(^6) This also means that each process implicitly determines the Unixtime of the start
of the next round, and computes all delays, e.g., the block candidate submission delays,
starting from this time.


```
Chapter3. Block Consensus Protocol
```
time, this block candidate has a very high chance to be accepted by the
protocol).
The first block producer may suggest a block candidate immediately after
the round starts. Other block producers can suggest block candidates only
after some delay∆i, whereiis the index of the producer in the list of desig-
nated block producers, with0 = ∆ 1 ≤∆ 2 ≤.... After some predetermined
period of time∆∞elapses from the round start, a specialnull candidate is
assumed automatically suggested (even if there are no explicit BCP events
to indicate this). Therefore, at mostC+ 1block candidates (including the
null candidate) are suggested in a round.

3.4.8. Suggesting a block candidate. A block candidate for the TON
Blockchain consists of two large “files” — the block and the collated data,
along with a small header containing the description of the block being gen-
erated (most importantly, the completeblock identifierfor the block candi-
date, containing the workchain and the shard identifier, the block sequence
number, its file hash and its root hash) and thesha256hashes of the two
large files. Only a part of this small header (including the hashes of the two
files and other important data) is used ascandidatein BCP events such as
SubmitorCommitSignto refer to a specific block candidate. The bulk of
the data (most importantly, the two large files) is propagated in the overlay
network associated with the catchain by the streaming broadcast protocol
implemented over ADNL for this purpose (cf. [3, 5]). This bulk data propa-
gation mechanism is unimportant for the validity of the consensus protocol
(the only important point is that the hashes of the large files are part of
BCP events and hence of the catchain messages, where they are signed by
the sender, and these hashes are checked after the large files are received
by any participating nodes; therefore, nobody can replace or corrupt these
files). A Submit(round,candidate)BCP event is created in the catchain
by the block producer in parallel with the propagation of the block candi-
date, indicating the submission of this specific block candidate by this block
producer.

3.4.9. Processing block candidates. Once a process observes aSubmit
BCP event in a delivered catchain message, it checks the validity of this
event (for instance, its originating process must be in the list of designated
producers, and current Unixtime must be at least the start of the round
plus the minimum delay∆i, where iis the index of this producer in the
list of designated producers), and if it is valid, remembers it in the current


```
Chapter3. Block Consensus Protocol
```
catchain state (cf.3.1). After that, when a streaming broadcast containing
the files associated with this block candidates (with correct hash values)
is received (or immediately, if these files are already present), the process
invokes a validator instance to validate the new block candidate (even if this
block candidate was suggested by this process itself!). Depending on the
result of this validation, either anApprove(round,candidate,signature)or
aReject(round,candidate)BCP event is created (and embedded into a new
catchain message). Note that thesignatureused inApproveevents uses the
same private key that will ultimately be used to sign the accepted block, but
the signature itself is different from that used inCommitSign(the hash of
a structure with different magic number is actually signed). Therefore, this
interim signature cannot be used to fake the acceptance of this block by this
particular validator process to an outside observer.

3.4.10. Overview of one round.Each round of BCP proceeds as follows:

- At the beginning of a round, several processes (from the predetermined
    list of designated producers) submit their block candidates (with cer-
    tain delays depending on their producer priority) and reflect this fact
    by means ofSubmitevents (incorporated into catchain messages).
- Once a process receives a submitted block candidate (i.e., observes a
    Submit event and receives all necessary files by means external to
    the consensus protocol), it starts the validation of this candidate and
    eventually creates either anApproveor aRejectevent for this block
    candidate.
- During eachfast attempt(i.e., one of the firstYattempts) every process
    votes either for a block candidate that has collected the votes of more
    than 2 / 3 of all processes, or, if there are no such candidates yet, for
    the valid (i.e., Approved by more than 2 / 3 of all processes) block
    candidate with the highest priority. The voting is performed by means
    of creatingVoteevents (embedded into new catchain messages).
- During each slow attempt (i.e., any attempt except the first Y) ev-
    ery process votes either for a candidate that wasPreCommitted be-
    fore (by the same process), or for a candidate that was suggested by
    VoteFor.


```
Chapter3. Block Consensus Protocol
```
- If a block candidate has received votes from more than 2 / 3 of all pro-
    cesses during the current attempt, and the current process observes
    these votes (which are collected in the catchain state), aPreCommit
    event is created, indicating that the process will vote only for this can-
    didate in future.
- If a block candidate collectsPreCommits from more than 2 / 3 of all
    processes inside an attempt, then it is assumed to be accepted (by
    the group), and each process that observes these PreCommits cre-
    ates aCommitSignevent with a valid block signature. These block
    signatures are registered in the catchain, and are ultimately collected
    to create a “block proof” (containing signatures of more than 2 / 3 of
    the validators for this block). This block proof is the external output
    of the consensus protocol (along with the block itself, but without its
    collated data); it is ultimately propagated in the overlay network of all
    full nodes that have subscribed to new blocks of this shard (or of the
    masterchain).
- Once a block candidate collects CommitSignsignatures from more
    than 2 / 3 of all validators, the round is considered finished (at least
    from the perspective of a process that observes all these signatures).
    After that, only aCommitSigncan be added to that round by this
    process, and the process automatically starts participating in the next
    round (and ignores all events related to other rounds).

Note that the above protocol may lead to a validator signing (in aCommitSign
event) a block candidate that wasRejected by the same validator before
(this is a kind of “submitting to the will of majority”).

3.4.11.VoteandPreCommitmessages are created deterministi-
cally.Note that each process can create at most oneVoteand at most one
PreCommitevent in each attempt. Furthermore, these events are com-
pletely determined by the stateσDmof the sender of catchain messagem
containing such an event. Therefore, the receiver can detect invalidVoteor
PreCommitevents and ignore them (thus mitigating byzantine behavior of
other participants). On the other hand, a messagemthat should contain a
Voteor aPreCommitevent according to the corresponding stateσDmbut
does not contain one can be received. In this case, the current implementa-
tion automatically creates missing events and proceeds as ifmhad contained


```
Chapter3. Block Consensus Protocol
```
them from the very beginning. However, such instances of byzantine behav-
ior are either corrected or ignored (and a message is output into the error
log), but the offending processes are not otherwise punished (because this
would require very large misbehavior proofs for outside observers that do
not have access to the internal state of the catchain).

3.4.12. MultipleVotes andPreCommits of the same process.Note
that a process usually ignores subsequentVotes andPreCommits gener-
ated by the same originating process inside the same attempt, so normally a
process can vote for at most one block candidate. However, it may happen
that a “good” process indirectly observes a fork created by a byzantine pro-
cess, withVotes for different block candidates in different branches of this
fork (this can happen if the “good” process learns about these two branches
from two other “good” processes that did not see this fork before). In this
case, bothVotes (for different candidates) are taken into account (added
into the merged state of the current process). A similar logic applies to
PreCommits.

3.4.13. Approving or rejecting block candidates. Notice that a block
candidate cannot beApproved orRejected before it has beenSubmitted
(i.e., anApproveevent that was not preceded by a correspondingSubmit
event will be ignored), and that a candidate cannot be approved before the
minimum time of its submission (the round start time plus the priority-
dependent delay∆i) is reached, i.e., any “good” process will postpone the
creation of itsApproveuntil this time. Furthermore, one cannotApprove
more than one candidate of the same producer in the same round (i.e., even
if a processSubmits several candidates, only one of them—presumably the
first one—will beApproved by other “good” processes; as usual, this means
that subsequentApprove events will be ignored by “good” processes on
receipt).

3.4.14. Approving the null block candidate. The implicit null block
candidate is also explicitly approved (by creating anApproveevent) by all
(good) processes, once the delay∆∞from the start of the round expires.

3.4.15. Choosing a block candidate for voting. Each process chooses
one of the available block candidates (including the implicit null candidate)
and votes for this candidate (by creating aVoteevent) by applying the
following rules (in the order they are presented):


```
Chapter3. Block Consensus Protocol
```
- If the current process created aPreCommitevent for a candidate dur-
    ing one of the previous attempts, and no other candidate has collected
    votes from more than 2 / 3 of all processes since (i.e., inside one of the
    subsequent attempts, including the current one so far; we say that the
    PreCommitevent is stillactivein this case), then the current process
    votes for this candidate again.
- If the current attempt is fast (i.e., one of the firstY attempts of a
    round from the perspective of the current process), and a candidate
    has collected votes from more than 2 / 3 of all processes during the
    current or one of the previous attempts, the current process votes for
    this candidate. In the case of a tie, the candidate from the latest of all
    such attempts is chosen.
- If the current attempt is fast, and the previous rules do not apply, then
    the process votes for the candidate with the highest priority among
    alleligible candidates, i.e., candidates that have collectedApproves
    (observable by the current process) from more than 2 / 3 of all processes.
- If the current attempt is slow, then the process votes only after it
    receives a validVoteForevent in the same attempt. If the first rule
    is applicable, the process votes according to it (i.e., for the previously
    PreCommited candidate). Otherwise it votes for the block candidate
    that is mentioned in theVoteForevent. If there are several such valid
    events (during the current attempt), the candidate with the smallest
    hash is selected (this may happen in rare situations related to different
    VoteForevents created in different branches of a fork, cf.3.4.12).

The “null candidate” is considered to have the least priority. It also requires
an explicitApprovebefore being voted for (with the exception of the first
two rules).

3.4.16. CreatingVoteForevents during slow attempts.AVoteFor
event is created at the beginning of a slow attempt by thecoordinator —
the process with index attemptmodN in the ordered list of all processes
participating in the catchain (as usual, this means that aVoteForcreated
by another process will be ignored by all “good” processes). ThisVoteFor
event refers to one of the block candidates (including the null candidate)
that have collectedApproves from more than 2 / 3 of all processes, usually
randomly chosen among all such candidates. Essentially, this is a suggestion


```
Chapter3. Block Consensus Protocol
```
to vote for this block candidate directed to all other processes that do not
have an activePreCommit.

3.5. Validity of BCP.Now we present a sketch of the proof of validity of
TON Block Consensus Protocol (BCP) described above in3.4, assuming that
less than one third of all processes exhibit byzantine (arbitrarily malicious,
possibly protocol-violating) behavior, as it is customary for Byzantine Fault
Tolerant protocols. During this subsection, we consider only one round of
BCP, subdivided into several attempts.

3.5.1. Fundamental assumption. Let us emphasize once again that we
assume thatless than one third of all processes are byzantine. All other
processes are assumed to begood, i.e., they follow the protocol.

3.5.2. Weighted BCP.The reasoning in this subsection is valid for the
weighted variant of BCPas well. In this variant, each process i ∈ I is
pre-assigned a positive weightwi> 0 (fixed in the genesis message of the
catchain), and statements about “more than 2 / 3 of all processes” and “less
than one third of all processes” are understood as “more than 2 / 3 of all
processes by weight”, i.e., “a subset∑ J ⊂ I of processes with total weight

```
j∈Jwj >
```
```
2
3
```
#### ∑

i∈Iwi”, and similarly for the second property. In particular,
our “fundamental assumption” 3.5.1is to be understood in the sense that
“the total weight of all byzantine processes is less than one third of the total
weight of all processes”.

3.5.3. Useful invariants.We collect here some useful invariants obeyed by
all BCP events during one round of BCP (inside a catchain). These invariants
are enforced in two ways. Firstly, any “good” (non-byzantine) process will
not create events violating these invariants. Secondly, even if a “bad” process
creates an event violating these invariants, all “good” processes will detect this
when a catchain message containing this event is delivered to BCP and ignore
such events. Some possible issues related to forks (cf. 3.4.12) remain even
after these precautions; we indicate how these issues are resolved separately,
and ignore them in this list. So:

- There is at most oneSubmitevent by each process (inside one round
    of BCP).
- There is at most oneApproveorRejectevent by each process re-
    lated to one candidate (more precisely, even if there are multiple candi-
    dates created by the same designated block producer, only one of them


```
Chapter3. Block Consensus Protocol
```
```
can beApproved by another process).^7 This is achieved by requiring
all “good” processes to ignore (i.e., not to createApproves orRejects
for) all candidates suggested by the same producer but the very first
one they have learned about.
```
- There is at most oneVoteand at most onePreCommitevent by
    each process during each attempt.
- There is at most oneVoteForevent during each (slow) attempt.
- There is at most oneCommitSignevent by each process.
- During a slow attempt, each process votes either for its previously
    PreCommitted candidate, or for the candidate indicated in theVoteFor
    event of this attempt.

One might somewhat improve the above statements by adding the word
“valid” where appropriate (e.g., there is at most onevalidSubmitevent... ).

3.5.4. More invariants.

- There is at most one eligible candidate (i.e., candidate that has received
    Approves from more than 2 / 3 of all processes) from each designated
    producer, and no eligible candidates from other producers.
- There are at mostC+ 1eligible candidates in total (at mostCcandi-
    dates fromC designated producers, plus the null candidate).
- A candidate may be accepted only if it has collected more than 2 / 3
    PreCommits during the same attempt (more precisely, a candidate is
    accepted only if there arePreCommitevents created by more than 2 / 3
    of all processes for this candidate and belonging to the same attempt).

(^7) In fact,Rejects appear only in this restriction, and do not affect anything else.
Therefore, any process can abstain from sendingRejects without violating the protocol,
andRejectevents could have been removed from the protocol altogether. Instead, the
current implementation of the protocol still generatesRejects, but does not check any-
thing on their receipt and does not remember them in the catchain state. Only a message
is output into the error log, and the offending candidate is stored into a special directory
for future study, becauseRejects usually indicate either the presence of a byzantine ad-
versary, or a bug in the collator (block generation) or validator (block verification) software
either on the node that suggested the block or on the node that created theRejectevent.


```
Chapter3. Block Consensus Protocol
```
- A candidate may beVoted for,PreCommitted, or mentioned in a
    VoteForonly if it is aneligible candidate, meaning that it has pre-
    viously collectedApproves from more than 2 / 3 of all validators (i.e.,
    a validVoteevent may be created for a candidate only ifApprove
    events for this candidate have been previously created by more than
    2 / 3 of all processes and registered in catchain messages observable from
    the message containing theVoteevent, and similarly forPreCommit
    andVoteForevents).

3.5.5. At most one block candidate is accepted. Now we claim that
at most one block candidate can be accepted (in a round of BCP). Indeed,
a candidate can be accepted only if it collects PreCommits from more
than 2 / 3 of all processes inside the same attempt. Therefore, two different
candidates cannot achieve this during the same attempt (otherwise more than
one third of all validators must have createdPreCommits for two different
candidates inside an attempt, thus violating the above invariants; but we
have assumed that less than one third of all validators exhibit byzantine
behavior). Now suppose that two different candidatesc 1 andc 2 have collected
PreCommits from more than 2 / 3 of all processes in two different attempts
a 1 anda 2. We may assume thata 1 < a 2. According to the first rule of
3.4.15, each process that has created aPreCommitforc 1 during attempt
a 1 must continue voting forc 1 in all subsequent attemptsa′> a 1 , or at least
cannot vote for any other candidate, unless another candidate c′ collects
Votes of more than 2 / 3 of all processes during a subsequent attempt (and
this invariant is enforced even if some processes attempt not to create these
newVoteevents forc 1 , cf.3.4.11). Therefore, ifc 26 =c 1 has collected the
necessary amount ofPreCommits during attempta 2 > a 1 , there is at least
one attempta′,a 1 < a′≤a 2 , such that somec′ 6 =c 1 (not necessarily equal
toc 2 ) has collectedVotes of more than 2 / 3 of all processes during attempt
a′. Let us fix the smallest sucha′, and the correspondingc′ 6 =c 1 that has
collected many votes during attempt a′. More than 2 / 3 of all validators
have voted forc′during attempta′, and more than 2 / 3 of all validators have
PreCommitted forc 1 during attempta 1 , and by the minimality ofa′there
was no attempta′′witha 1 < a′′< a′, such that a candidate distinct from
c 1 collected more than 2 / 3 of all votes during attempta′′. Therefore, all
validators thatPreCommitted forc 1 could vote only forc 1 during attempt
a′, and at the same time we supposed thatc′has collected votes from more
than 2 / 3 of all validators during the same attempt a′. This implies that


```
Chapter3. Block Consensus Protocol
```
more than 1 / 3 of all validators have somehow voted both forc 1 andc′during
this attempt (or voted forc′while they could have voted only forc 1 ), i.e.,
more than 1 / 3 of all validators have exhibited byzantine behavior. This is
impossible by our fundamental assumption3.5.1.

3.5.6. At most one block candidate may bePreCommitted during
one attempt. Note that all valid PreCommit events (if any) created
inside the same attempt must refer to the same block candidate, by the
same reasoning as in the first part of3.5.5: since a validPreCommitevent
for a candidatecmay be created only after votes from more than 2 / 3 of
all processes are observed for this candidate inside the same attempt (and
invalidPreCommits are ignored by all good processes), the existence of
validPreCommitevents for different candidatesc 1 andc 2 inside the same
attempt would imply that more than one third of all processes have voted
both forc 1 andc 2 inside this attempt, i.e., they have exhibited byzantine
behavior. This is impossible in view of our fundamental assumption3.5.1.

3.5.7. A previousPreCommitis deactivated by the observation of
a newer one.We claim thatwhenever a process with an activePreCommit
observes a validPreCommitcreated by any process in a later attempt for a
different candidate, its previously activePreCommitis deactivated. Recall
that we say that a process has anactivePreCommitif it has created a
PreCommitfor a certain candidatecduring a certain attempta, did not
create anyPreCommitduring any attemptsa′ > a, and did not observe
votes of more than 2 / 3 of all validators for any candidate 6 =cduring any
attemptsa′> a. Any process has at most one activePreCommit, and if it
has one, it must vote only for the precommitted candidate.
Now we see that if a process with an activePreCommitfor a candidate
csince attempta observes a validPreCommit (usually by another pro-
cess) for a candidatec′created during some later attempta′> a, then the
first process must also observe all dependencies of the message that contains
the newerPreCommit; these dependencies necessarily include validVotes
from more than 2 / 3 of all validators for the same candidatec′ 6 =ccreated
during the same attempta′> a(because otherwise the newerPreCommit
would not be valid, and would be ignored by the other process); by definition,
the observation of all theseVotes deactivates the originalPreCommit.

3.5.8. Assumptions for proving the convergence of the protocol.
Now we are going to prove that the protocol described aboveconverges(i.e.,


```
Chapter3. Block Consensus Protocol
```
terminates after accepting a block candidate) with probability one under
some assumptions, which essentially tell us that there are enough “good”
processes (i.e., processes that diligently follow the protocol and do not in-
troduce arbitrary delays before sending their new messages), and that these
good processes enjoy good network connectivity at least from time to time.
More precisely, our assumptions are as follows:

- There is a subsetI+⊂Iconsisting of “good” processes and containing
    more than 2 / 3 of all processes.
- All processes from I+have well-synchronized clocks (differing by at
    mostτ, whereτis a bound for network latency described below).
- If there are infinitely many attempts, then infinitely many attempts are
    “good” with respect to network connectivity between processes fromI+,
    meaning that all messages created by a process fromI+during this
    attempt or earlier are delivered to any other process fromI+within
    at most τ > 0 seconds after being created with probability at least
    q > 0 , whereτ > 0 and 0 < q < 1 are some fixed parameters, such that
    5 τ < K, whereKis the duration of one attempt.
- Furthermore, if the protocol runs for infinitely many attempts, then
    any arithmetic progression of attempts contains infinitely many “good”
    attempts in the sense described above.
- A process fromI+creates a VoteForduring a slow attempt after
    some fixed or random delay after the start of the slow attempt, in such
    a way that this delay belongs to the interval(τ,K− 3 τ)with probability
    at leastq′, whereq′> 0 is a fixed parameter.
- A process from I+, when it is its turn to be the coordinator of a
    slow attempt, chooses a candidate forVoteForuniformly at random
    among all eligible candidates (i.e., those candidates that have collected
    Approves from more than 2 / 3 of all validators).

3.5.9. The protocol terminates under these assumptions. Now we
claim that(each round of) the BCP protocol as described above terminates
with probability one under the assumptions listed in3.5.8. The proof pro-
ceeds as follows.


```
Chapter3. Block Consensus Protocol
```
- Let us assume that the protocol does not converge. Then it continues
    running forever. We are going to ignore the first several attempts, and
    consider only attemptsa 0 ,a 0 + 1,a 0 + 2,... starting from somea 0 , to
    be chosen later.
- Since all processes fromI+continue participating in the protocol, they
    will create at least one message not much later than the start of the
    round (which may be perceived slightly differently by each process).
    For instance, they will create anApprovefor the null candidate no
    later than∆∞seconds from the start of the round. Therefore, they will
    consider all attempts slow at mostKYseconds afterwards. By choosing
    a 0 appropriately, we can assume that all attempts we consider are slow
    from the perspective of all processes fromI+.
- After a “good” attempt a ≥ a 0 all processes from I+ will see the
    Approves for the null candidate created by all other processes fromI+,
    and will deem the null candidate eligible henceforth. Since there are
    infinitely many “good” attempts, this will happen sooner or later with
    probability one. Therefore, we can assume (increasinga 0 if necessary)
    that there is at least one eligible candidate from the perspective of all
    processes fromI+, namely, the null candidate.
- Furthermore, there will be infinitely many attemptsa ≥a 0 that are
    perceived slow by all processes fromI+, that have a coordinator from
    I+, and that are “good” (with respect to the network connectivity) as
    defined in3.5.8. Let us call such attempts “very good”.
- Consider one “very good” slow attempta. With probability q′ > 0 ,
    its coordinator (which belongs to I+) will wait forτ′ ∈(τ,K− 3 τ)
    seconds before creating itsVoteForevent. Consider the most recent
    PreCommitevent created by any process fromI+; let us suppose it
    was created during attempta′< afor some candidatec′. With prob-
    abilityqq′> 0 , the catchain message carrying thisPreCommitwill
    be already delivered to the coordinator at the time of generation of
    itsVoteForevent. In that case, the catchain message carrying this
    VoteForwill depend on thisPreCommit(c′)event, and all “good”
    processes that observe thisVoteForwill also observe its dependen-
    cies, including thisPreCommit(c′). We see thatwith probability at
    leastqq′, all processes fromI+that receive theVoteForevent during


```
Chapter3. Block Consensus Protocol
```
```
a “very good” slow attempt receive also the most recentPreCommit
(if any).
```
- Next, consider any process fromI+that receives thisVoteFor, for
    a randomly chosen eligible candidate c, and suppose that there are
    already somePreCommits, and that the previous statement holds.
    Since there are at mostC+ 1eligible candidates (cf.3.5.4), with prob-
    ability at least 1 /(C+ 1)> 0 we’ll havec=c′, wherec′is the most re-
    centlyPreCommitted candidate (there is at most one such candidate
    by3.5.6). In this case, all processes fromI+will vote forc=c′during
    this attempt immediately after they receive thisVoteFor(which will
    be delivered to any processj∈I+less thanK− 2 τ seconds after the
    beginning of the attempt with probabilityqq′). Indeed, if a processj
    fromI+did not have an activePreCommit, it will vote for the value
    indicated inVoteFor, which isc. Ifjhad an activePreCommit,
    and it is as recent as possible, i.e., also created during attempta′, then
    it must have been aPreCommitfor the same valuec′=c(because
    we know about at least one validPreCommitforc′ during attempt
    a′, and all other validPreCommits during attempta′must be for the
    samec′ by 3.5.6). Finally, ifj had an activePreCommitfrom an
    attempt< a′, then it will become inactive once theVoteForwith all
    its dependencies (including the newerPreCommit(c′)) has been deliv-
    ered to this processj(cf.3.5.7), and the process will again vote for the
    valuecindicated inVoteFor. Therefore, all processes fromI+will
    vote for the samec=c′during this attempt, less thanK− 2 τseconds
    after the beginning of the attempt (with some probability bounded
    away from zero).
- If there are noPreCommits yet, then the above reasoning simplifies
    further: all processes fromI+that receive thisVoteForwill imme-
    diately vote for the candidatecsuggested by thisVoteFor.
- In both cases, all processes fromI+will create aVotefor the same
    candidatecless thanK− 2 τseconds from the beginning of the attempt,
    and this will happen with a positive probability bounded away from
    zero.
- Finally, all processes fromI+will receive theseVotes forcfrom all
    processes fromI+, again less than (K− 2 τ) +τ = K−τ seconds


```
Chapter3. Block Consensus Protocol
```
```
after the beginning of this attempt, i.e., still during the same attempt
(even after taking into account the imperfect clock synchronization
between processes fromI+). This means that they will all create a
valid PreCommit forc, i.e., the protocol will acceptc during this
attempt with probability bounded away from zero.
```
- Since there are infinitely many “very good” attempts, and the proba-
    bility of successful termination during each such attempt is≥p > 0
    for some fixed value ofp, the protocol will terminate successfully with
    probability one.


```
References
```
## References

[1] K. Birman,Reliable Distributed Systems: Technologies, Web Services
and Applications, Springer, 2005.

[2] M. Castro, B. Liskov, et al., Practical byzantine fault tolerance,
Proceedings of the Third Symposium on Operating Systems Design and
Implementation(1999), p. 173–186, available athttp://pmg.csail.mit.
edu/papers/osdi99.pdf.

[3] N. Durov,Telegram Open Network, 2017.

[4] N. Durov,Telegram Open Network Blockchain, 2018.

[5] L. Lamport, R. Shostak, M. Pease,The byzantine generals problem,
ACM Transactions on Programming Languages and Systems,4/3(1982),
p. 382–401.

[6] A. Miller, Yu Xia, et al., The honey badger of BFT protocols,
Cryptology e-print archive 2016/99,https://eprint.iacr.org/2016/
199.pdf, 2016.

[7] M. van Steen, A. Tanenbaum,Distributed Systems, 3rd ed., 2017.


